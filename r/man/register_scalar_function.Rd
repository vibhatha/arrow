% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute.R
\name{register_scalar_function}
\alias{register_scalar_function}
\alias{arrow_scalar_function}
\alias{arrow_base_scalar_function}
\title{Register user-defined functions}
\usage{
register_scalar_function(name, scalar_function, registry_name = name)

arrow_scalar_function(in_type, out_type, fun)

arrow_base_scalar_function(in_type, out_type, base_fun)
}
\arguments{
\item{name}{The function name to be used in the dplyr bindings}

\item{scalar_function}{An object created with \code{\link[=arrow_scalar_function]{arrow_scalar_function()}}
or \code{\link[=arrow_base_scalar_function]{arrow_base_scalar_function()}}.}

\item{registry_name}{The function name to be used in the Arrow C++
compute function registry. This may be different from \code{name}.}

\item{in_type}{A \link{DataType} of the input type or a \code{\link[=schema]{schema()}}
for functions with more than one argument. This signature will be used
to determine if this function is appropriate for a given set of arguments.
If this function is appropriate for more than one signature, pass a
\code{list()} of the above.}

\item{out_type}{A \link{DataType} of the output type or a function accepting
a single argument (\code{types}), which is a \code{list()} of \link{DataType}s. If a
function it must return a \link{DataType}.}

\item{fun}{An R function or rlang-style lambda expression. This function
will be called with R objects as arguments and must return an object
that can be converted to an \link{Array} using \code{\link[=as_arrow_array]{as_arrow_array()}}. Function
authors must take care to return an array castable to the output data
type specified by \code{out_type}.}

\item{base_fun}{An R function or rlang-style lambda expression. This
function will be called with exactly two arguments: \code{kernel_context},
which is a \code{list()} of objects giving information about the
execution context and \code{args}, which is a list of \link{Array} or \link{Scalar}
objects corresponding to the input arguments.}
}
\value{
\itemize{
\item \code{register_scalar_function()}: \code{NULL}, invisibly
\item \code{arrow_scalar_function()}: returns an object of class
"arrow_base_scalar_function" that can be passed to
\code{register_scalar_function()}.
}
}
\description{
These functions support calling R code from query engine execution
(i.e., a \code{\link[dplyr:mutate]{dplyr::mutate()}} or \code{\link[dplyr:filter]{dplyr::filter()}} on a \link{Table} or \link{Dataset}).
Use \code{\link[=arrow_scalar_function]{arrow_scalar_function()}} to define an R function that accepts and
returns R objects; use \code{\link[=arrow_base_scalar_function]{arrow_base_scalar_function()}} to define a
lower-level function that operates directly on Arrow objects.
}
\examples{
fun_wrapper <- arrow_scalar_function(
  schema(x = float64(), y = float64(), z = float64()),
  float64(),
  function(x, y, z) x + y + z
)
register_scalar_function("example_add3", fun_wrapper)

call_function(
  "example_add3",
  Scalar$create(1),
  Scalar$create(2),
  Array$create(3)
)

# use arrow_base_scalar_function() for a lower-level interface
base_fun_wrapper <- arrow_base_scalar_function(
  schema(x = float64(), y = float64(), z = float64()),
  float64(),
  function(kernel_context, args) {
    args[[1]] + args[[2]] + args[[3]]
  }
)
register_scalar_function("example_add3", base_fun_wrapper)

call_function(
  "example_add3",
  Scalar$create(1),
  Scalar$create(2),
  Array$create(3)
)

}
